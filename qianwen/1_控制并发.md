
```js
function timeoutPromise(delay) {
  return new Promise((resolve) => {
    setTimeout(resolve, delay);
  });
}

// æ§åˆ¶å¹¶å‘
class SuperTask {
  constructor(parallelCount = 2) {
    // æœ€å¤§å¹¶å‘æ•°
    // this.maxConcurrency = maxConcurrency;
    this.parallelCount = parallelCount;
    this.runningTasks = 0;
    this.taskQueue = [];
  }

  add(task) {
    return new Promise((resolve, reject) => {
      const wrappedTask = () => {
        return Promise.resolve(task()).then(resolve).catch(reject);
      };
      this.taskQueue.push(wrappedTask);
      this.executeTask();
    });
  }

  executeTask() {
    if (this.runningTasks < this.parallelCount && this.taskQueue.length > 0) {
      this.runningTasks++;
      const task = this.taskQueue.shift();
      try {
        Promise.resolve(task()).then(() => {
          console.log('Task completed');
        })
      } catch (error) {
        console.error('Task failed:', error);
      } finally {
        this.runningTasks--;
        if (this.taskQueue.length > 0) {
          this.executeTask();
        }
      }
    }
  }
}
const superTask = new SuperTask();

function addTask(time, name) {
  superTask.add(() => {
    // console.log(`Task ${name} started`);
    return timeoutPromise(time).then(() => {
      if (name === "6") {
        throw new Error("Task 6 failed");
      }
      console.log(`Task ${name} completed after ${time}ms`);
    });
  });
}

// æ·»åŠ ä»»åŠ¡
// addTask(10000, "1");
// addTask(5000, "2");
// addTask(3000, "3");
// addTask(4000, "4");
// addTask(5000, "5");

addTask(1000, "1");
// å¼‚å¸¸ä»»åŠ¡
addTask(1000, "6");

addTask(1000, "2");
addTask(1000, "3");
addTask(1000, "4");
addTask(1000, "5");
// ä»»åŠ¡å¼‚å¸¸æ—¶ï¼Œä»èƒ½ç»§ç»­è¿è¡Œå…¶ä½™ä»»åŠ¡
```


è¿™æ®µä»£ç æœ‰ä¸€ä¸ª**å…³é”®é—®é¢˜**ï¼š`finally` å—ä¼š**åŒæ­¥æ‰§è¡Œ**ï¼Œä½†ä»»åŠ¡æ˜¯**å¼‚æ­¥**çš„ï¼Œå¯¼è‡´å¹¶å‘æ§åˆ¶å¤±æ•ˆã€‚è®©æˆ‘åˆ†æå¹¶æä¾›ä¿®å¤æ–¹æ¡ˆã€‚

## ğŸ”´ é—®é¢˜åˆ†æ

```javascript
executeTask() {
  if (this.runningTasks < this.parallelCount && this.taskQueue.length > 0) {
    this.runningTasks++;
    const task = this.taskQueue.shift();
    try {
      Promise.resolve(task()).then(() => {
        console.log('Task completed');
      })
    } catch (error) {
      console.error('Task failed:', error);
    } finally {
      this.runningTasks--;  // âŒ è¿™é‡Œä¼šç«‹å³æ‰§è¡Œï¼Œä¸æ˜¯ç­‰ä»»åŠ¡å®Œæˆå
      if (this.taskQueue.length > 0) {
        this.executeTask();
      }
    }
  }
}
```

**é—®é¢˜**ï¼š`runningTasks--` åœ¨ä»»åŠ¡å®Œæˆå‰å°±æ‰§è¡Œäº†ï¼Œå¯¼è‡´å¹¶å‘é™åˆ¶å¤±æ•ˆã€‚

## âœ… ä¿®å¤æ–¹æ¡ˆ

```javascript
class SuperTask {
  constructor(parallelCount = 2) {
    this.parallelCount = parallelCount;
    this.runningTasks = 0;
    this.taskQueue = [];
  }

  add(task) {
    return new Promise((resolve, reject) => {
      const wrappedTask = () => {
        return Promise.resolve(task())
          .then(resolve)
          .catch(err => {
            console.error('Task error:', err.message);
            resolve(); // å…³é”®ï¼šå³ä½¿å¤±è´¥ä¹Ÿ resolveï¼Œè®©é˜Ÿåˆ—ç»§ç»­
          });
      };
      this.taskQueue.push(wrappedTask);
      this.executeTask();
    });
  }

  executeTask() {
    while (this.runningTasks < this.parallelCount && this.taskQueue.length > 0) {
      this.runningTasks++;
      const task = this.taskQueue.shift();

      // âœ… åœ¨ Promise é“¾ä¸­å¤„ç†å®Œæˆé€»è¾‘
      task().finally(() => {
        this.runningTasks--;
        this.executeTask(); // ä»»åŠ¡å®Œæˆåæ‰æ‰§è¡Œä¸‹ä¸€ä¸ª
      });
    }
  }
}
```

## ğŸ“Š å…³é”®ä¿®å¤ç‚¹

| é—®é¢˜ | åŸä»£ç  | ä¿®å¤å |
|------|--------|--------|
| `finally` æ‰§è¡Œæ—¶æœº | åŒæ­¥ç«‹å³æ‰§è¡Œ | å¼‚æ­¥ï¼Œç­‰ä»»åŠ¡å®Œæˆ |
| ä»»åŠ¡å¤±è´¥å¤„ç† | å¯èƒ½ä¸­æ–­é˜Ÿåˆ— | `catch` åç»§ç»­ |
| å¹¶å‘æ§åˆ¶ | å¤±æ•ˆ | æ­£å¸¸å·¥ä½œ |
| é˜Ÿåˆ—è°ƒåº¦ | å•æ¬¡æ£€æŸ¥ | `while` å¾ªç¯å¡«æ»¡å¹¶å‘ |

## ğŸ§ª æµ‹è¯•è¾“å‡º

ä¿®å¤åè¿è¡Œä½ çš„æµ‹è¯•ä»£ç ï¼Œé¢„æœŸè¾“å‡ºï¼š

```
Task 1 completed after 1000ms
Task 6 failed (é”™è¯¯è¢«æ•è·)
Task 2 completed after 1000ms
Task 3 completed after 1000ms
Task 4 completed after 1000ms
Task 5 completed after 1000ms
```

**æ‰€æœ‰ä»»åŠ¡éƒ½ä¼šæ‰§è¡Œ**ï¼Œå³ä½¿ä»»åŠ¡ 6 æŠ›å‡ºå¼‚å¸¸ã€‚

## ğŸ’¡ é¢å¤–å»ºè®®

1. **æ·»åŠ ä»»åŠ¡æ€»æ•°è¿½è¸ª**ï¼šä¾¿äºè°ƒè¯•å’Œç›‘æ§
2. **æ”¯æŒä»»åŠ¡å–æ¶ˆ**ï¼šå¢åŠ  `cancel()` æ–¹æ³•
3. **æ·»åŠ è¶…æ—¶æœºåˆ¶**ï¼šé˜²æ­¢ä»»åŠ¡å¡æ­»

éœ€è¦æˆ‘å¸®ä½ å®ç°å®Œæ•´ç‰ˆæœ¬å—ï¼Ÿ


## âœ… å®Œæ•´ç‰ˆæœ¬ï¼šSuperTask å¹¶å‘ä»»åŠ¡æ§åˆ¶å™¨

```javascript
/**
 * è¶…æ—¶åŒ…è£…å™¨
 */
function timeoutPromise(delay) {
  return new Promise((resolve) => {
    setTimeout(resolve, delay);
  });
}

/**
 * å¸¦è¶…æ—¶çš„ä»»åŠ¡åŒ…è£…å™¨
 */
function withTimeout(promise, timeout, taskName) {
  return Promise.race([
    promise,
    timeoutPromise(timeout).then(() => {
      throw new Error(`Task "${taskName}" timeout after ${timeout}ms`);
    })
  ]);
}

/**
 * å¯å–æ¶ˆçš„ Promise åŒ…è£…å™¨
 */
function makeCancellable(promise) {
  let isCancelled = false;
  let cancelFn = null;

  const wrappedPromise = new Promise((resolve, reject) => {
    cancelFn = () => {
      isCancelled = true;
      reject(new Error('Task cancelled'));
    };

    promise
      .then(result => {
        if (!isCancelled) resolve(result);
      })
      .catch(error => {
        if (!isCancelled) reject(error);
      });
  });

  return {
    promise: wrappedPromise,
    cancel: cancelFn,
    isCancelled: () => isCancelled
  };
}

/**
 * SuperTask - å¹¶å‘ä»»åŠ¡æ§åˆ¶å™¨
 */
class SuperTask {
  constructor(options = {}) {
    const {
      parallelCount = 2,      // æœ€å¤§å¹¶å‘æ•°
      defaultTimeout = 30000, // é»˜è®¤è¶…æ—¶æ—¶é—´ (ms)
      enableLogging = true    // æ˜¯å¦å¯ç”¨æ—¥å¿—
    } = options;

    this.parallelCount = parallelCount;
    this.defaultTimeout = defaultTimeout;
    this.enableLogging = enableLogging;

    // ä»»åŠ¡è¿½è¸ª
    this.taskQueue = [];           // ç­‰å¾…é˜Ÿåˆ—
    this.runningTasks = new Map(); // è¿è¡Œä¸­çš„ä»»åŠ¡ (id -> taskInfo)
    this.completedTasks = [];      // å·²å®Œæˆä»»åŠ¡
    this.failedTasks = [];         // å¤±è´¥ä»»åŠ¡
    this.cancelledTasks = [];      // å·²å–æ¶ˆä»»åŠ¡

    // è®¡æ•°å™¨
    this.totalAdded = 0;   // æ€»æ·»åŠ æ•°
    this.totalCompleted = 0;
    this.totalFailed = 0;
    this.totalCancelled = 0;

    // ä»»åŠ¡ ID ç”Ÿæˆå™¨
    this.taskIdCounter = 0;

    // å…¨å±€å–æ¶ˆæ ‡å¿—
    this.isGlobalCancelled = false;
  }

  /**
   * æ·»åŠ ä»»åŠ¡
   */
  add(task, options = {}) {
    const {
      timeout = this.defaultTimeout,
      name = `task-${++this.taskIdCounter}`,
      priority = 0  // ä¼˜å…ˆçº§ï¼Œæ•°å­—è¶Šå¤§ä¼˜å…ˆçº§è¶Šé«˜
    } = options;

    const taskId = ++this.taskIdCounter;
    this.totalAdded++;

    return new Promise((resolve, reject) => {
      const taskInfo = {
        id: taskId,
        name,
        task,
        timeout,
        priority,
        createdAt: Date.now(),
        startedAt: null,
        completedAt: null,
        status: 'pending',  // pending, running, completed, failed, cancelled
        resolve,
        reject,
        cancelFn: null
      };

      // æŒ‰ä¼˜å…ˆçº§æ’å…¥é˜Ÿåˆ—
      this._insertByPriority(taskInfo);

      this._log(`[ADD] Task "${name}" (id:${taskId}) added to queue`);
      this.executeTask();
    });
  }

  /**
   * æŒ‰ä¼˜å…ˆçº§æ’å…¥é˜Ÿåˆ—
   */
  _insertByPriority(taskInfo) {
    let inserted = false;
    for (let i = this.taskQueue.length - 1; i >= 0; i--) {
      if (this.taskQueue[i].priority <= taskInfo.priority) {
        this.taskQueue.splice(i + 1, 0, taskInfo);
        inserted = true;
        break;
      }
    }
    if (!inserted) {
      this.taskQueue.unshift(taskInfo);
    }
  }

  /**
   * æ‰§è¡Œä»»åŠ¡
   */
  executeTask() {
    if (this.isGlobalCancelled) return;

    while (
      this.runningTasks.size < this.parallelCount &&
      this.taskQueue.length > 0
    ) {
      const taskInfo = this.taskQueue.shift();
      this._runTask(taskInfo);
    }
  }

  /**
   * è¿è¡Œå•ä¸ªä»»åŠ¡
   */
  _runTask(taskInfo) {
    taskInfo.status = 'running';
    taskInfo.startedAt = Date.now();
    this.runningTasks.set(taskInfo.id, taskInfo);

    this._log(`[RUN] Task "${taskInfo.name}" started (${this.runningTasks.size}/${this.parallelCount})`);

    // åˆ›å»ºå¯å–æ¶ˆçš„ä»»åŠ¡
    const cancellable = makeCancellable(
      withTimeout(
        Promise.resolve(taskInfo.task()),
        taskInfo.timeout,
        taskInfo.name
      )
    );

    taskInfo.cancelFn = cancellable.cancel;

    cancellable.promise
      .then(result => {
        this._onTaskComplete(taskInfo, null, result);
      })
      .catch(error => {
        if (error.message === 'Task cancelled') {
          this._onTaskCancelled(taskInfo);
        } else {
          this._onTaskComplete(taskInfo, error, null);
        }
      });
  }

  /**
   * ä»»åŠ¡å®Œæˆå›è°ƒ
   */
  _onTaskComplete(taskInfo, error, result) {
    taskInfo.completedAt = Date.now();
    this.runningTasks.delete(taskInfo.id);

    if (error) {
      taskInfo.status = 'failed';
      this.failedTasks.push(taskInfo);
      this.totalFailed++;
      this._log(`[FAIL] Task "${taskInfo.name}" failed: ${error.message}`);
      taskInfo.reject(error);
    } else {
      taskInfo.status = 'completed';
      this.completedTasks.push(taskInfo);
      this.totalCompleted++;
      this._log(`[DONE] Task "${taskInfo.name}" completed (${taskInfo.completedAt - taskInfo.startedAt}ms)`);
      taskInfo.resolve(result);
    }

    // ç»§ç»­æ‰§è¡Œé˜Ÿåˆ—ä¸­çš„ä»»åŠ¡
    this.executeTask();
  }

  /**
   * ä»»åŠ¡å–æ¶ˆå›è°ƒ
   */
  _onTaskCancelled(taskInfo) {
    taskInfo.completedAt = Date.now();
    taskInfo.status = 'cancelled';
    this.runningTasks.delete(taskInfo.id);
    this.cancelledTasks.push(taskInfo);
    this.totalCancelled++;
    this._log(`[CANCEL] Task "${taskInfo.name}" cancelled`);
    taskInfo.reject(new Error('Task cancelled'));
    this.executeTask();
  }

  /**
   * å–æ¶ˆå•ä¸ªä»»åŠ¡
   */
  cancel(taskId) {
    // æ£€æŸ¥è¿è¡Œä¸­çš„ä»»åŠ¡
    const runningTask = this.runningTasks.get(taskId);
    if (runningTask) {
      if (runningTask.cancelFn) {
        runningTask.cancelFn();
        this._log(`[CANCEL] Task "${runningTask.name}" (id:${taskId}) cancellation requested`);
        return true;
      }
    }

    // æ£€æŸ¥ç­‰å¾…é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡
    const queueIndex = this.taskQueue.findIndex(t => t.id === taskId);
    if (queueIndex !== -1) {
      const taskInfo = this.taskQueue.splice(queueIndex, 1)[0];
      taskInfo.status = 'cancelled';
      this.cancelledTasks.push(taskInfo);
      this.totalCancelled++;
      this._log(`[CANCEL] Task "${taskInfo.name}" (id:${taskId}) removed from queue`);
      taskInfo.reject(new Error('Task cancelled'));
      return true;
    }

    this._log(`[WARN] Task (id:${taskId}) not found for cancellation`);
    return false;
  }

  /**
   * å–æ¶ˆæ‰€æœ‰ä»»åŠ¡
   */
  cancelAll() {
    this.isGlobalCancelled = true;

    // å–æ¶ˆè¿è¡Œä¸­çš„ä»»åŠ¡
    for (const [id, taskInfo] of this.runningTasks) {
      if (taskInfo.cancelFn) {
        taskInfo.cancelFn();
      }
    }

    // å–æ¶ˆé˜Ÿåˆ—ä¸­çš„ä»»åŠ¡
    while (this.taskQueue.length > 0) {
      const taskInfo = this.taskQueue.shift();
      taskInfo.status = 'cancelled';
      this.cancelledTasks.push(taskInfo);
      this.totalCancelled++;
      taskInfo.reject(new Error('Task cancelled'));
    }

    this._log(`[CANCEL ALL] All tasks cancelled`);
  }

  /**
   * è·å–ä»»åŠ¡ç»Ÿè®¡ä¿¡æ¯
   */
  getStats() {
    const now = Date.now();
    return {
      totalAdded: this.totalAdded,
      totalCompleted: this.totalCompleted,
      totalFailed: this.totalFailed,
      totalCancelled: this.totalCancelled,
      running: this.runningTasks.size,
      pending: this.taskQueue.length,
      queue: this.taskQueue.map(t => ({
        id: t.id,
        name: t.name,
        priority: t.priority,
        waitingTime: now - t.createdAt
      })),
      runningTasks: Array.from(this.runningTasks.values()).map(t => ({
        id: t.id,
        name: t.name,
        runningTime: now - t.startedAt,
        timeout: t.timeout
      })),
      utilization: this.runningTasks.size / this.parallelCount
    };
  }

  /**
   * æ‰“å°ç»Ÿè®¡ä¿¡æ¯
   */
  printStats() {
    const stats = this.getStats();
    console.log('\n========== SuperTask Stats ==========');
    console.log(`Total Added:     ${stats.totalAdded}`);
    console.log(`Completed:       ${stats.totalCompleted}`);
    console.log(`Failed:          ${stats.totalFailed}`);
    console.log(`Cancelled:       ${stats.totalCancelled}`);
    console.log(`Running:         ${stats.running}`);
    console.log(`Pending:         ${stats.pending}`);
    console.log(`Utilization:     ${(stats.utilization * 100).toFixed(1)}%`);
    console.log('=====================================\n');
  }

  /**
   * ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
   */
  waitForAll() {
    return new Promise((resolve) => {
      const check = () => {
        if (
          this.runningTasks.size === 0 &&
          this.taskQueue.length === 0
        ) {
          resolve(this.getStats());
        } else {
          setTimeout(check, 100);
        }
      };
      check();
    });
  }

  /**
   * æ—¥å¿—è¾“å‡º
   */
  _log(message) {
    if (this.enableLogging) {
      console.log(message);
    }
  }
}
```

---

## ğŸ§ª ä½¿ç”¨ç¤ºä¾‹

```javascript
// åˆ›å»ºå®ä¾‹
const superTask = new SuperTask({
  parallelCount: 2,
  defaultTimeout: 5000,
  enableLogging: true
});

// æ·»åŠ ä»»åŠ¡
const task1 = superTask.add(
  () => timeoutPromise(1000).then(() => console.log('Task 1 done')),
  { name: 'task-1', timeout: 3000 }
);

const task2 = superTask.add(
  () => timeoutPromise(2000).then(() => { throw new Error('Task 2 failed'); }),
  { name: 'task-2' }
);

const task3 = superTask.add(
  () => timeoutPromise(10000).then(() => console.log('Task 3 done')),
  { name: 'task-3-slow', timeout: 2000 }  // ä¼šè¶…æ—¶
);

// é«˜ä¼˜å…ˆçº§ä»»åŠ¡
const task4 = superTask.add(
  () => timeoutPromise(500).then(() => console.log('Task 4 done')),
  { name: 'task-4-urgent', priority: 10 }
);

// å–æ¶ˆå•ä¸ªä»»åŠ¡
// setTimeout(() => {
//   superTask.cancel(3);
// }, 500);

// ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
(async () => {
  const stats = await superTask.waitForAll();
  superTask.printStats();
})();
```

---

## ğŸ“Š åŠŸèƒ½å¯¹æ¯”

| åŠŸèƒ½ | åŸä»£ç  | æ–°ç‰ˆæœ¬ |
|------|--------|--------|
| å¹¶å‘æ§åˆ¶ | âŒ å¤±æ•ˆ | âœ… æ­£å¸¸å·¥ä½œ |
| å¼‚å¸¸å¤„ç† | âš ï¸ ä¸å®Œæ•´ | âœ… å®Œæ•´æ•è· |
| ä»»åŠ¡è¿½è¸ª | âŒ æ—  | âœ… å®Œæ•´ç»Ÿè®¡ |
| ä»»åŠ¡å–æ¶ˆ | âŒ æ—  | âœ… æ”¯æŒå•ä¸ª/å…¨éƒ¨ |
| è¶…æ—¶æœºåˆ¶ | âŒ æ—  | âœ… å¯é…ç½® |
| ä¼˜å…ˆçº§ | âŒ æ—  | âœ… æ”¯æŒ |
| ç­‰å¾…å®Œæˆ | âŒ æ—  | âœ… waitForAll() |
| æ—¥å¿—ç›‘æ§ | âŒ æ—  | âœ… å¯é…ç½® |

---

## ğŸ¯ æ ¸å¿ƒä¼˜åŠ¿

1. **ä»»åŠ¡å¼‚å¸¸ä¸å½±å“å…¶ä»–ä»»åŠ¡** - æ¯ä¸ªä»»åŠ¡ç‹¬ç«‹å¤„ç†
2. **ç²¾ç¡®çš„å¹¶å‘æ§åˆ¶** - `runningTasks` Map å®æ—¶è¿½è¸ª
3. **çµæ´»çš„è¶…æ—¶é…ç½®** - å…¨å±€é»˜è®¤ + å•ä¸ªä»»åŠ¡è¦†ç›–
4. **å®Œæ•´çš„å¯è§‚æµ‹æ€§** - ç»Ÿè®¡ä¿¡æ¯ + æ—¥å¿—è¾“å‡º
5. **ä¼˜é›…çš„ä»»åŠ¡å–æ¶ˆ** - æ”¯æŒè¿è¡Œä¸­å’Œé˜Ÿåˆ—ä¸­çš„ä»»åŠ¡

éœ€è¦æˆ‘é’ˆå¯¹æŸä¸ªåŠŸèƒ½è¿›ä¸€æ­¥æ‰©å±•å—ï¼Ÿ
