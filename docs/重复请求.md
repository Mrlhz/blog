

>在前端或 Node 环境中，页面加载时如果会触发很多服务请求，容易出现 重复请求 的问题。这不仅浪费资源，还可能导致数据不一致。解决思路主要有以下几类：
1. 请求去重（防抖/节流）
- 防抖 (debounce)：在短时间内多次触发同一请求，只执行最后一次。
- 节流 (throttle)：限制某个请求在一定时间窗口内只执行一次。
```js
let timer;
function debounceRequest(fn, delay = 300) {
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => fn(...args), delay);
  };
}
```
2. 请求缓存
- 在发起请求前，检查是否已有相同参数的请求结果。
- 可以用 Map 或 WeakMap 缓存请求 Promise。

```js
const requestCache = new Map();

function fetchWithCache(url) {
  if (requestCache.has(url)) {
    return requestCache.get(url);
  }
  const promise = fetch(url).then(res => res.json());
  requestCache.set(url, promise);
  return promise;
}
```

3. 请求合并
- 如果多个地方需要同一数据，可以合并为一次请求。
- 例如在 `Vue3/React` 中，用 `全局状态管理（Pinia/Redux）` 或 `单例服务` 来共享结果。

4. 请求锁（防并发）
- 在请求发起时设置一个“锁”，直到请求完成才允许再次发起。

```js
let isFetching = false;

async function safeFetch(url) {
  if (isFetching) return;
  isFetching = true;
  try {
    const res = await fetch(url);
    return await res.json();
  } finally {
    isFetching = false;
  }
}
```

5. 后端层面去重
- 在服务端对相同参数的请求做幂等处理，避免重复执行逻辑。
- 例如：请求签名校验、幂等 ID、缓存层。

在 Vue3/前端项目中的实践
- 使用 Axios 拦截器：在请求发出前检查是否已有相同请求在进行。
- 使用 Pinia/Vuex：把数据请求集中管理，避免组件重复拉取。
- 使用 Suspense/async setup：在 Vue3 中可以让多个组件共享同一个异步请求。

总结：
前端可以通过 防抖/节流、缓存、锁机制 来避免重复请求；后端则通过 幂等性设计 来保证安全。

你的场景是 Vue3 + Chrome 扩展开发，还是 Node 服务端？我可以帮你写一个 Axios 请求去重拦截器 或 fetch 封装，让你在项目里直接用。要不要我给你一个 Vue3 + Axios 的完整示例？



这是一个在 Vue3 项目中常见的场景：父组件循环渲染多个子组件，而每个子组件在 mounted 或 setup 阶段都会发起服务请求，导致重复调用。解决思路主要有两类：`避免子组件重复请求` 和 `集中管理请求`。

1. 父组件统一请求，子组件只消费数据
- 在父组件中发起一次请求，拿到数据后通过 props 或 provide/inject 传递给子组件。
- 子组件只负责展示，不再自己请求。
```vue
<!-- Parent.vue -->
<template>
  <Child v-for="item in data" :key="item.id" :info="item" />
</template>

<script setup>
import { ref, onMounted } from 'vue';
import Child from './Child.vue';

const data = ref([]);

onMounted(async () => {
  const res = await fetch('/api/service');
  data.value = await res.json();
});
</script>
```
```vue
<!-- Child.vue -->
<template>
  <div>{{ info.name }}</div>
</template>

<script setup>
defineProps({ info: Object });
</script>

```

2. 使用全局状态管理（Pinia/Vuex）
- 将请求逻辑放在 store 中，保证只请求一次。
- 子组件通过 store 获取数据，避免重复调用。

```js
// store.js (Pinia)
import { defineStore } from 'pinia';

export const useDataStore = defineStore('data', {
  state: () => ({ items: [] }),
  actions: {
    async fetchData() {
      if (this.items.length) return; // 已有数据则不再请求
      const res = await fetch('/api/service');
      this.items = await res.json();
    }
  }
});

```

```vue
<!-- Child.vue -->
<script setup>
import { useDataStore } from './store';
const store = useDataStore();
store.fetchData(); // 只会请求一次
</script>
```

3. 请求缓存/去重
- 封装请求函数，利用 Map 缓存相同参数的请求结果。
- 子组件调用时，如果已有缓存，就直接返回，不再发起新请求。

```js
const requestCache = new Map();

async function fetchWithCache(url) {
  if (requestCache.has(url)) return requestCache.get(url);
  const promise = fetch(url).then(res => res.json());
  requestCache.set(url, promise);
  return promise;
}
```

4. 父子通信优化
- 如果子组件确实需要独立请求，可以通过事件或 emit 通知父组件，由父组件统一调度。
- 父组件维护一个请求池，避免重复。

总结
- 最佳实践：父组件统一请求 → 子组件只展示（最简单、最稳定）。
- 复杂场景：使用 Pinia/Vuex 管理数据，保证请求只发起一次。
- 特殊情况：封装请求缓存，避免相同参数重复调用。



3. 请求缓存/去重
- 如果子组件确实要自己调用接口，可以封装一个带缓存的请求函数：
```js
const cache = new Map();

async function fetchWithCache(url) {
  if (cache.has(url)) return cache.get(url);
  const promise = fetch(url).then(res => res.json());
  cache.set(url, promise);
  return promise;
}
```

场景是：父组件循环渲染多个子组件，每个子组件都会调用同一个接口，但传入的参数可能相同也可能不同。这种情况容易导致重复请求，尤其是参数相同的情况。下面给你几种稳妥的解决方案：

1. 父组件统一调度请求
- 父组件收集所有子组件需要的参数。
- 去重后统一发起请求，再把结果分发给子组件。
```vue
<!-- Parent.vue -->
<template>
  <Child v-for="param in params" :key="param" :data="results[param]" />
</template>

<script setup>
import { ref, onMounted } from 'vue';
import Child from './Child.vue';

const params = ['a', 'b', 'a']; // 子组件需要的参数
const results = ref({});

onMounted(async () => {
  const uniqueParams = [...new Set(params)];
  for (const p of uniqueParams) {
    const res = await fetch(`/api/service?param=${p}`).then(r => r.json());
    results.value[p] = res;
  }
});
</script>
```



2. 请求缓存（推荐）
- 封装一个带缓存的请求函数，子组件直接调用，不会重复请求相同参数。
```js
const cache = new Map();

async function fetchWithCache(param) {
  if (cache.has(param)) return cache.get(param);
  const promise = fetch(`/api/service?param=${param}`).then(res => res.json());
  cache.set(param, promise);
  return promise;
}

```
子组件调用：
```vue
<script setup>
import { ref, onMounted } from 'vue';
import { fetchWithCache } from './api';

const props = defineProps({ param: String });
const data = ref(null);

onMounted(async () => {
  data.value = await fetchWithCache(props.param);
});
</script>
```

3. 全局状态管理（Pinia/Vuex）
- 在 store 中维护一个 Map 或对象，存储每个参数对应的请求结果。
- 子组件调用时，先检查 store 是否已有数据，没有才发起请求。

```js
// store.js
import { defineStore } from 'pinia';

export const useDataStore = defineStore('data', {
  state: () => ({ results: {} }),
  actions: {
    async fetchData(param) {
      if (this.results[param]) return this.results[param];
      const res = await fetch(`/api/service?param=${param}`).then(r => r.json());
      this.results[param] = res;
      return res;
    }
  }
});
```
子组件调用：
```vue
<script setup>
import { ref, onMounted } from 'vue';
import { useDataStore } from './store';

const props = defineProps({ param: String });
const store = useDataStore();
const data = ref(null);

onMounted(async () => {
  data.value = await store.fetchData(props.param);
});
</script>
```


```js
// api.js
import axios from 'axios';

// 请求缓存池
const pendingRequests = new Map();

// 生成请求唯一 key
function getRequestKey(config) {
  const { method, url, params, data } = config;
  return [
    method,
    url,
    JSON.stringify(params),
    JSON.stringify(data)
  ].join('&');
}

// 创建 Axios 实例
const instance = axios.create({
  baseURL: '/api',
  timeout: 10000
});

// 请求拦截器
instance.interceptors.request.use(config => {
  const key = getRequestKey(config);

  if (pendingRequests.has(key)) {
    // 已有相同请求，复用 Promise
    return pendingRequests.get(key);
  }

  // 创建请求 Promise
  const requestPromise = new Promise((resolve, reject) => {
    config.resolve = resolve;
    config.reject = reject;
  });

  pendingRequests.set(key, requestPromise);
  return config;
});

// 响应拦截器
instance.interceptors.response.use(
  response => {
    const key = getRequestKey(response.config);

    if (pendingRequests.has(key)) {
      // 触发所有等待的 resolve
      pendingRequests.get(key).resolve(response);
      pendingRequests.delete(key);
    }

    return response.data;
  },
  error => {
    const key = getRequestKey(error.config || {});
    if (pendingRequests.has(key)) {
      pendingRequests.get(key).reject(error);
      pendingRequests.delete(key);
    }
    return Promise.reject(error);
  }
);

export default instance;
```
```js
```
```js
```
```js
```
```js
```
```js
```
```js
```
```js
```
```js
```
```js
```
